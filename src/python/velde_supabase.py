"""Client-side security controls testing program.

This program checks the status of your security controls, and automatically
updates your caa dashboard. This program does not access, transmit, or store
any of your sensitive data, such as login credentials, GRB data (customer
data) or PCI data (card numbers).

Also, whenever a finding has been detected, this program gives you an option
to run action flows, which can then remediate the findings.

Developer: Soobin Rho <soobinrho@gmail.com>

Example:
    >>> # How to run this program. This fits most of the use cases.
    >>> python ./caa_supabase.py

Example:
    >>> # If you want to make direct changes to the source code, use the debugging mode to help you.
    >>> python ./caa_supabase.py -d

Example:
    >>> # How to see all available parameters.
    >>> python ./caa_supabase.py -h
"""

# This section is auto generated by #REPLACE#
# -----------------------------------------------------------------------------
# Designed for: #REPLACE#
# Generated at: #REPLACE#
# -----------------------------------------------------------------------------
import os
import platform
import subprocess
import sys
import time
import argparse
import json
import re
import time
import datetime
import urllib.parse
import base64
from time import strftime

sys.tracebacklimit = 0

try:
    # Python 3
    import tkinter as tk  # type: ignore
    import tkinter.messagebox as messagebox  # type: ignore
except:
    # Python 2
    import Tkinter as tk  # type: ignore
    import Tkinter.messagebox as messagebox  # type: ignore

try:
    import pytest
    from playwright.sync_api import sync_playwright
except:
    subprocess.check_call(
        [sys.executable, '-m', 'pip', 'install', '-U', 'pytest'])
    subprocess.check_call([sys.executable, '-m', 'pip',
                          'install', '-U', 'pytest-playwright'])
    subprocess.check_call(
        [sys.executable, '-m', 'playwright', 'install', '--with-deps', 'chromium'])
finally:
    import pytest
    from playwright.sync_api import sync_playwright

try:
    import requests
    from requests.auth import HTTPBasicAuth
except:
    subprocess.check_call(
        [sys.executable, '-m', 'pip', 'install', '-U', 'requests'])
finally:
    import requests
    from requests.auth import HTTPBasicAuth

# This section is auto generated by #REPLACE#
# -----------------------------------------------------------------------------
# WARNING: Do not share this file outside your company. The values below are
# unique for you. The authentication key and secret below grant this program
# access rights to your caa Dashboard.
VELDE_REST_API_USER = '#REPLACE#'
VELDE_REST_API_KEY = '#REPLACE#'
VELDE_URL_BASE = '#REPLACE#'
VELDE_EMAIL = '#REPLACE#'
USER_EMAIL = '#REPLACE#'
USER_UID = '#REPLACE#'
APP_URL_BASE = '#REPLACE#'
APP_NAME = '#REPLACE#'
# -----------------------------------------------------------------------------

parser = argparse.ArgumentParser(
    prog=os.path.realpath(__file__),
    description='The purpose of this program is to check the current status of Supabase security controls set in place and gather the evidence in the form of screenshots.',
    epilog=f'If you have any questions, please feel free to reach out to {VELDE_EMAIL}',
    add_help=False)
parser.add_argument('-h', '--help', action='help', default=argparse.SUPPRESS,
                    help='Show this help message.')
parser.add_argument('-q', '--quiet', action='store_true',
                    help='Do not print [INFO] messages.')
parser.add_argument('-d', '--debug', action='store_true',
                    help='Activate helper functions for debugging. For example, session storage including cookies is enabled, thus preserving login data from each session instead of resetting, which is the default behaivor for data security.')
parser.add_argument('-i', '--inspector', action='store_true',
                    help="Activate Playwright Inspector. Supports live editing for locators and code walkthrough.")

parser.set_defaults(debug=False)
parser.set_defaults(quiet=False)
parser.set_defaults(inspector=False)
args = parser.parse_args()
is_debug_on = args.debug
is_quiet_on = args.quiet
is_inspector_on = args.inspector


def get_env(key):
    path_env_test_local = os.path.join(os.path.dirname(
        os.path.realpath(__file__)), '.env.test.local')
    path_env_test = os.path.join(os.path.dirname(
        os.path.realpath(__file__)), '.env.test')
    path = ''
    if os.path.exists(path_env_test_local):
        path = path_env_test_local
    else:
        if os.path.exists(path_env_test):
            path = path_env_test

    if path != '':
        with open(path, encoding='utf-8', mode='r') as f:
            for line in f:
                line = line.strip()
                if not line.startswith('#') and line:
                    line_key = line.split('=')[0]
                    if line_key and line_key == key:
                        value = line.split('=')[1].strip('"')
                        return value

    return ''


def get_findings_summary_string(list_findings):
    str_findings_summary = ''
    for i in range(len(list_findings)):
        str_findings_summary += f'\n{i+1}. {list_findings[i]}.'
    return str_findings_summary


def get_log_template(
        PRI_SEVERITY,
        VER,
        MSG,
        TIMESTAMP=f'{datetime.datetime.now(datetime.timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z')}',
        HOSTNAME=f'{platform.uname()[1].replace(' ', '_')}',
        APPNAME=f'Supabase_secured_by_caa',
        PROCID=f'{os.path.realpath(__file__).replace(' ', '_')}'):
    dict_log = {'PRI_FACILITY': 23,
                'PRI_SEVERITY': PRI_SEVERITY,
                'VER': VER,
                'TIMESTAMP': TIMESTAMP,
                'HOSTNAME': HOSTNAME,
                'APPNAME': APPNAME,
                'PROCID': PROCID,
                'MSG': MSG}
    return dict_log


def print_info(str_info, org_id='', user_email='', project_id='', table_project_id='', table_name=''):
    if not is_quiet_on:
        # Green background color.
        print('\x1b[6;30;42m' + str_info + '\x1b[0m')

    payload = get_log_template(PRI_SEVERITY=6,
                               VER=1,
                               MSG=str_info)
    if org_id != '':
        payload['org_id'] = org_id
    if user_email != '':
        payload['user_email'] = user_email
    if project_id != '':
        payload['project_id'] = project_id
    if table_project_id != '':
        payload['table_project_id'] = table_project_id
    if table_name != '':
        payload['table_name'] = table_name

    list_json_payload = [payload]
    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='logs',
                     route_url='api/v1/logs')


def print_debug(str_debug, *args):
    if is_debug_on and not is_quiet_on:
        print(str_debug, *args)


def print_error(str_error, org_id='', user_email='', project_id='', table_project_id='', table_name='', do_not_send_api_request=False):
    if not is_quiet_on:
        # Yellow background color.
        print('\x1b[6;30;43m' + str_error + '\x1b[0m')

    payload = get_log_template(PRI_SEVERITY=3,
                               VER=1,
                               MSG=str_error)
    if org_id != '':
        payload['org_id'] = org_id
    if user_email != '':
        payload['user_email'] = user_email
    if project_id != '':
        payload['project_id'] = project_id
    if table_project_id != '':
        payload['table_project_id'] = table_project_id
    if table_name != '':
        payload['table_name'] = table_name

    list_json_payload = [payload]
    list_json_payload = json.dumps(list_json_payload)
    if not do_not_send_api_request:
        request_post_api(list_json_payload=list_json_payload,
                         db_table_name='logs',
                         route_url='api/v1/logs')


def print_finding(str_finding, org_id='', user_email='', project_id='', table_project_id='', table_name=''):
    if not is_quiet_on:
        # Yellow background color.
        print('\x1b[6;30;43m' + str_finding + '\x1b[0m')

    payload = get_log_template(PRI_SEVERITY=2,
                               VER=1,
                               MSG=str_finding)
    if org_id != '':
        payload['org_id'] = org_id
    if user_email != '':
        payload['user_email'] = user_email
    if project_id != '':
        payload['project_id'] = project_id
    if table_project_id != '':
        payload['table_project_id'] = table_project_id
    if table_name != '':
        payload['table_name'] = table_name

    list_json_payload = [payload]
    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='logs',
                     route_url='api/v1/logs')


def print_warning(str_warning):
    # Yellow background color.
    print('\x1b[6;30;43m' + str_warning + '\x1b[0m')


def request_post_api(list_json_payload, db_table_name, route_url):
    # The API key in this file only allows you to call POST and PUT methods.
    # GET can only be called internally via the dashboard.
    # Also, the HTTPBasicAuth object doesn't encrypt the data on its own.
    # Thus, make sure HTTPS/SSL is set up correctly.
    api_auth = HTTPBasicAuth(VELDE_REST_API_USER, VELDE_REST_API_KEY)
    api_url = f'{VELDE_URL_BASE}/{route_url}'

    try:
        req = requests.post(api_url,
                            data=list_json_payload,
                            auth=api_auth)
        if req.status_code == 201:  # HTTP status code 201 (Created).
            print_debug(
                f'[DEBUG] Successful HTTP POST request for the "{db_table_name}" table.')
        else:
            print_error(
                f'[ERROR] {req.status_code} "{req.reason}" error on HTTP PUT request for updating {db_table_name} via {route_url}.', do_not_send_api_request=True)
            print_error(f'[ERROR] {req.json()}', do_not_send_api_request=True)

    except Exception as e:
        print_error(
            f'[ERROR] Failed HTTP POST request for updating the {db_table_name} table.', do_not_send_api_request=True)
        print_error(
            f'[ERROR] Message: {e}', do_not_send_api_request=True)


def request_delete_api(params, db_table_name, route_url):
    api_auth = HTTPBasicAuth(VELDE_REST_API_USER, VELDE_REST_API_KEY)
    api_url = f'{VELDE_URL_BASE}/{route_url}'

    try:
        req = requests.delete(api_url,
                              params=params,
                              auth=api_auth)
        if req.status_code == 204:  # HTTP status code 204 (No Content).
            print_debug(
                f'[DEBUG] Successful HTTP DELETE request for the "{db_table_name}" table.')
        else:
            print_error(
                f'[ERROR] {req.status_code} "{req.reason}" error on HTTP DELETE request for the "{db_table_name}" table via {route_url}.', do_not_send_api_request=True)
            print_error(f'[ERROR] {req.json()}', do_not_send_api_request=True)

    except Exception as e:
        print_error(
            f'[ERROR] Failed HTTP DELETE request for the {db_table_name} table.', do_not_send_api_request=True)
        print_error(
            f'[ERROR] Message: {e}', do_not_send_api_request=True)


def wait_for_all_loading(page, HIGHLIGHT_DURATION):
    page.wait_for_load_state('domcontentloaded')
    page.wait_for_timeout(HIGHLIGHT_DURATION)
    while True:
        is_all_loading_invisible = True
        try:
            for loading in page.locator('.shimmering-loader').all():
                if loading.is_visible():
                    is_all_loading_invisible = False
        except:
            pass

        try:
            if page.locator('.shimmering-loader').count() == 0:
                break
        except:
            pass

        if is_all_loading_invisible:
            break

        page.wait_for_timeout(HIGHLIGHT_DURATION)


def sanitize_file_name(file_name):
    for char in ['\\', '/', ':', '*', '?', '"', '>', '<', '|', '`', '!', '$']:
        if char in file_name:
            file_name = file_name.replace(char, '_')
    return file_name


def exit_program():
    pytest.skip(allow_module_level=True)


def test_supabase_action_flow_core():
    """Perform the core action flows.

    This function updates the current status of security controls in place, and
    performs remediation action flows if there's any finding.

    This function has a prefix of 'test_' because that's how Pytest knows which
    function to run Playwright with.
    """
    print_warning(f'[WARNING] AUTHORIZED USERS ONLY')
    print_warning(f"[WARNING] This program is intended for '{USER_EMAIL}' only.")
    print_info(f'[INFO] Requesting for the warning prompt...')

    is_yes = messagebox.askyesno(
        title='CONFIDENTIAL', message=f"AUTHORIZED USERS ONLY\n\nThis program is intended for '{USER_EMAIL}' only. This program evaluates your compliance status and executes action flows to make your system more secure.\n\nTo start, please click Yes.")

    if not is_yes:
        print_info(
            '[INFO] User decline the initial prompt. Exiting the program.')
        exit_program()

    # Milliseconds.
    HIGHLIGHT_DURATION = 200 if is_debug_on else 500

    print_info(f'[INFO] Initializing {APP_URL_BASE}')
    playwright = sync_playwright().start()
    browser = playwright.chromium.launch(
        headless=False, args=['--start-maximized'])

    path_test_login_session = '_test_login_session.json'
    if is_debug_on:
        if not os.path.exists(path_test_login_session):
            path_test_login_session = None
    elif not is_debug_on:
        path_test_login_session = None

    context = browser.new_context(
        no_viewport=True, storage_state=path_test_login_session)

    page = context.new_page()
    url_dashboard = f'{APP_URL_BASE}/dashboard/'
    page.goto(url_dashboard)
    wait_for_all_loading(page, HIGHLIGHT_DURATION)

    try:
        page.wait_for_load_state('domcontentloaded')
        page.get_by_role('button', name='Sign In').first.wait_for(
            state='attached', timeout=HIGHLIGHT_DURATION)
        is_logged_in = False
    except:
        page.wait_for_load_state('domcontentloaded')
        page.get_by_text('New project').first.wait_for(
            state='visible', timeout=HIGHLIGHT_DURATION)
        is_logged_in = True

    if not is_logged_in:
        # In testing (debugging) mode, we're allowed to store email and
        # password for test accounts. However, in prod, the user will
        # be asked to always enter their credentials manually.
        if is_debug_on:
            TEST_SUPABASE_EMAIL = get_env('TEST_SUPABASE_EMAIL')
            TEST_SUPABASE_PW = get_env('TEST_SUPABASE_PW')
            page.get_by_role('textbox', name='Email').first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)
            page.get_by_role('textbox', name='Email').first.click()
            page.get_by_role('textbox', name='Email').first.press_sequentially(
                TEST_SUPABASE_EMAIL, delay=80)
            page.get_by_role('textbox', name='Password').first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)
            page.get_by_role('textbox', name='Password').first.click()
            page.get_by_role('textbox', name='Password').first.press_sequentially(
                TEST_SUPABASE_PW, delay=50)
            page.get_by_role('button', name='Sign In').first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)
            page.get_by_role('button', name='Sign In').first.click()

        # Using browswer API instead of using `'sign-in' in page.url` because
        # `page.url` intentionally doesn't update when manually redirected.
        # Source:
        #   https://github.com/microsoft/playwright/issues/16072#issuecomment-1200470460
        while 'sign-in' in page.evaluate('() => window.location.href'):
            print_info(f'[INFO] Requesting for sign-in prompt...')
            is_ok = messagebox.askokcancel(
                title='caa',
                message="SECURE LOGIN REQUIRED\n\nAlthough the rest of the process has been automated, we ask you to sign-in manually so that your credentials never leave your environment.\n\nAt caa, we prioritize your security and privacy as best as absolutely can. After you're logged in, please click OK."
            )
            if not is_ok:
                print_info(
                    '[INFO] User opted to exit before signing in to Supabase. Exiting the program.')
                exit_program()

    wait_for_all_loading(page, HIGHLIGHT_DURATION)

    if is_debug_on:
        test_login_session_saved = context.storage_state(
            path="_test_login_session.json")

    # ----------------------------------------------------------------------- #
    # Update the list of organizations.
    # ----------------------------------------------------------------------- #
    print_debug(
        f'[DEBUG] Looking up the list of {APP_NAME} organizations...')

    list_org_id = []
    list_org_name = []
    list_org_url = []
    for anchor in page.locator('a.block').all():
        href_project = anchor.get_attribute('href')
        if href_project and '/org/' in href_project:
            # Target example: `/dashboard/org/noibzwdbdmqxznouhiuz/general`
            org_id = href_project.partition(
                '/org/')[2].partition('/general')[0]
            org_name = anchor.text_content()
            org_url = href_project
            anchor.first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)

            list_org_id.append(org_id)
            list_org_name.append(org_name)
            list_org_url.append(org_url)

    request_delete_api(params={'delete_all': True},
                       db_table_name='organizations',
                       route_url='api/v1/organizations')

    print_debug('[DEBUG] list_org_id, list_org_name')
    print_debug(list_org_id, list_org_name)
    list_json_payload = []
    for i in range(len(list_org_id)):
        payload = {'org_id': list_org_id[i],
                   'org_name': list_org_name[i],
                   'org_last_updated_on_caa': int(time.time())}
        list_json_payload.append(payload)

    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='organizations',
                     route_url='api/v1/organizations')

    NAME_MFA = 'MFA (Multi Factor Authentication)'
    NAME_PITR = 'PITR (Point-In-Time Recovery)'
    NAME_RLS = 'RLS (Row Level Security)'
    list_findings_discovered = []
    # ----------------------------------------------------------------------- #
    # Check MFA (Multi Factor Authentication) is on for all users.
    # ----------------------------------------------------------------------- #
    print_debug(
        f'[DEBUG] Looking up the list of {APP_NAME} users...')

    request_delete_api(params={'delete_all': True},
                       db_table_name='evidence_images',
                       route_url='api/v1/evidence-images')

    list_user_email = []
    list_user_is_mfa_enabled = []
    list_org_member_org_id_fk = []
    list_org_member_user_email_fk = []
    list_org_member_role = []
    dict_user_email_is_finding_printed = {}
    for i in range(len(list_org_id)):
        org_id = list_org_id[i]
        org_name = list_org_name[i]
        org_url = list_org_url[i]

        team_url = f'{APP_URL_BASE}/{org_url}'.replace('general', 'team')
        page.goto(team_url)
        page.wait_for_load_state('domcontentloaded')
        page.get_by_role('row').first.wait_for(state='visible')

        # This is localtime.
        evidence_what_for = 'MFA'
        evidence_image_name = f'{strftime("%Y-%m-%d %H%M%S")} {NAME_MFA} {org_name}.png'
        evidence_image_name = sanitize_file_name(evidence_image_name)
        evidence_image_blob = page.screenshot(full_page=True)
        evidence_image_blob = base64.b64encode(evidence_image_blob).decode('utf-8')
        evidence_image_size = len(evidence_image_blob)
        print_debug(
            f'[DEBUG] evidence_image_name, evidence_image_size')
        print_debug(f"{evidence_image_size / 1024 / 1024:.2f}MB " + evidence_image_name)
        print_info(
            f'[INFO] Collected evidence for {NAME_MFA} for "{org_name}"', org_id=org_id)
        list_payload = []
        list_payload.append({
            'org_id': org_id,
            'evidence_what_for': evidence_what_for,
            'evidence_image_name': evidence_image_name,
            'evidence_image_size': evidence_image_size,
            'evidence_image_blob': evidence_image_blob,
            'evidence_image_last_updated_on_caa': int(time.time())
        })
        list_json_payload = json.dumps(list_payload)
        request_post_api(list_json_payload=list_json_payload,
                         db_table_name='evidence_images',
                         route_url='api/v1/evidence-images')

        # rows[0] = the row with the headers.
        # rows[-1] = the row containing total number of users.
        # Thus, skip these two.
        rows = page.get_by_role('row').all()
        for i in range(len(rows) - 2):
            row = rows[i + 1]
            cells = row.get_by_role('cell').all()

            user_email = cells[0].get_by_role('paragraph').first.text_content()
            cells[0].first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)

            user_is_mfa_enabled = True if 'lucide-check' in cells[2].inner_html(
            ) else False
            cells[2].first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)
            if not user_is_mfa_enabled:
                if not NAME_MFA in list_findings_discovered:
                    list_findings_discovered.append(NAME_MFA)
                if not user_email in dict_user_email_is_finding_printed:
                    print_finding(
                        f'[FINDING] {NAME_MFA} for "{user_email}" is disabled.',
                        org_id=org_id,
                        user_email=user_email)
                    dict_user_email_is_finding_printed[user_email] = True

            org_member_org_id_fk = org_id
            org_member_user_email_fk = user_email
            org_member_role = cells[3].inner_text()
            cells[3].first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)

            if not user_email in list_user_email:
                list_user_email.append(user_email)
                list_user_is_mfa_enabled.append(user_is_mfa_enabled)

            list_org_member_org_id_fk.append(org_member_org_id_fk)
            list_org_member_user_email_fk.append(org_member_user_email_fk)
            list_org_member_role.append(org_member_role)

    print_debug('[DEBUG] list_user_email, list_user_is_mfa_enabled')
    print_debug(list_user_email, list_user_is_mfa_enabled)
    list_json_payload = []
    for i in range(len(list_user_email)):
        user_is_mfa_enabled = 1 if list_user_is_mfa_enabled[i] else 0
        payload = {'user_email': list_user_email[i],
                   'user_is_mfa_enabled': user_is_mfa_enabled,
                   'user_last_updated_on_caa': int(time.time())}
        list_json_payload.append(payload)

    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='users',
                     route_url='api/v1/users')

    list_json_payload = []
    for i in range(len(list_org_member_org_id_fk)):
        payload = {'org_id_fk': list_org_member_org_id_fk[i],
                   'user_email_fk': list_org_member_user_email_fk[i],
                   'org_member_role': list_org_member_role[i]}
        list_json_payload.append(payload)

    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='organization_members',
                     route_url='api/v1/organization-members')

    # ----------------------------------------------------------------------- #
    # Check PITR (Point-In-Time Recovery) is on for all projects.
    # ----------------------------------------------------------------------- #
    print_debug(
        f'[DEBUG] Looking up the list of {APP_NAME} projects...')

    page.goto(f'{APP_URL_BASE}/dashboard/projects')
    page.wait_for_load_state('domcontentloaded')
    page.get_by_text('New project').first.wait_for(state='visible')

    # If you do any `page.goto()` operation in a loop, `page.locator()` value
    # gets updated reflecting the new page. Thus, I use two loops here.
    anchors = page.locator('a').all()
    list_href_project = []
    list_href_project_text_content = []
    for anchor in anchors:
        try:
            href_project = anchor.get_attribute('href')
        except:
            continue

        if href_project and re.match(r"/dashboard/project/[^/]+$", href_project):
            list_href_project.append(href_project)
            list_href_project_text_content.append(anchor.text_content())
            anchor.first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION)

    list_project_id = []
    list_project_org_id_fk = []
    list_project_name = []
    list_project_is_pitr_enabled = []
    for i in range(len(list_href_project)):
        href_project = list_href_project[i]
        href_project_text_content = list_href_project_text_content[i]

        # Target example: '/dashboard/project/dpgmwpkjqgwthtthklq'
        project_id = href_project.partition('/project/')[2]
        project_name = href_project_text_content

        page.goto(
            f'{APP_URL_BASE}/dashboard/project/{project_id}/database/backups/pitr')
        page.get_by_text('Point in time').first.wait_for(state='visible')
        wait_for_all_loading(page, HIGHLIGHT_DURATION)
        page.get_by_text('Point in time').first.highlight()
        page.wait_for_timeout(HIGHLIGHT_DURATION)

        org_id_fk = ''
        for button in page.get_by_role('button').all():
            try:
                if button.get_attribute('data-sentry-source-file', timeout=100) == 'OrganizationDropdown.tsx':
                    org_name_fk = button.get_by_role(
                        'paragraph').text_content()
                    for i in range(len(list_org_id)):
                        if org_name_fk == list_org_name[i]:
                            org_id_fk = list_org_id[i]
            except:
                continue

        evidence_what_for = 'PITR'
        evidence_image_name = f'{strftime("%Y-%m-%d %H%M%S")} {NAME_PITR} {project_name}.png'
        evidence_image_name = sanitize_file_name(evidence_image_name)
        evidence_image_blob = page.screenshot(full_page=True)
        evidence_image_blob = base64.b64encode(evidence_image_blob).decode('utf-8')
        evidence_image_size = len(evidence_image_blob)
        print_debug(
            f'[DEBUG] evidence_image_name, evidence_image_size')
        print_debug(f"{evidence_image_size / 1024 / 1024:.2f}MB " + evidence_image_name)
        print_info(
            f'[INFO] Collected evidence for {NAME_PITR} for "{project_name}"', org_id=org_id_fk, project_id=project_id)
        list_payload = []
        list_payload.append({
            'org_id': org_id_fk,
            'project_id': project_id,
            'evidence_what_for': evidence_what_for,
            'evidence_image_name': evidence_image_name,
            'evidence_image_size': evidence_image_size,
            'evidence_image_blob': evidence_image_blob,
            'evidence_image_last_updated_on_caa': int(time.time())
        })
        list_json_payload = json.dumps(list_payload)
        request_post_api(list_json_payload=list_json_payload,
                         db_table_name='evidence_images',
                         route_url='api/v1/evidence-images')

        # I don't have pro subscription, so I had to guess using:
        #   https://github.com/supabase/supabase/blob/master/apps/studio/pages/project/%5Bref%5D/database/backups/pitr.tsx
        project_is_pitr_enabled = False
        page.get_by_text('Point in time').first.highlight()
        try:
            page.get_by_text('Upgrade to Pro').first.wait_for(
                state='visible', timeout=3000)
        except:
            try:
                page.get_by_text(
                    'Please enable the add-on to enable point in time recovery for your project.').first.wait_for(state='visible', timeout=1500)
            except:
                project_is_pitr_enabled = True

        if not project_is_pitr_enabled:
            print_finding(
                f'[FINDING] {NAME_PITR} for "{project_name}" is disabled.',
                org_id=org_id_fk,
                project_id=project_id)
            if not NAME_PITR in list_findings_discovered:
                list_findings_discovered.append(NAME_PITR)

        list_project_id.append(project_id)
        list_project_org_id_fk.append(org_id_fk)
        list_project_name.append(project_name)
        list_project_is_pitr_enabled.append(project_is_pitr_enabled)

    print_debug(
        '[DEBUG] list_project_name, list_project_is_pitr_enabled')
    print_debug(list_project_name, list_project_is_pitr_enabled)
    list_json_payload = []
    for i in range(len(list_project_id)):
        project_is_pitr_enabled = 1 if list_project_is_pitr_enabled[i] else 0
        payload = {'project_id': list_project_id[i],
                   'org_id_fk': list_project_org_id_fk[i],
                   'project_name': list_project_name[i],
                   'project_is_pitr_enabled': project_is_pitr_enabled,
                   'project_last_updated_on_caa': int(time.time())}
        list_json_payload.append(payload)

    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='projects',
                     route_url='api/v1/projects')

    # ----------------------------------------------------------------------- #
    # Check RLS (Row Level Security) is on for all Postgres tables.
    # ----------------------------------------------------------------------- #
    print_debug(
        f'[DEBUG] Looking up the list of {APP_NAME} tables...')

    list_table_project_id_fk = []
    list_table_name = []
    list_table_is_rls_enabled = []
    for i in range(len(list_project_id)):
        project_id = list_project_id[i]
        project_name = list_project_name[i]
        page.goto(
            f'{APP_URL_BASE}/dashboard/project/{project_id}/auth/policies')
        wait_for_all_loading(page, HIGHLIGHT_DURATION)

        evidence_what_for = 'RLS'
        evidence_image_name = f'{strftime("%Y-%m-%d %H%M%S")} {NAME_RLS} {project_name}.png'
        evidence_image_name = sanitize_file_name(evidence_image_name)
        evidence_image_blob = page.screenshot(full_page=True)
        evidence_image_blob = base64.b64encode(evidence_image_blob).decode('utf-8')
        evidence_image_size = len(evidence_image_blob)
        print_debug(
            f'[DEBUG] evidence_image_name, evidence_image_size')
        print_debug(f"{evidence_image_size / 1024 / 1024:.2f}MB " + evidence_image_name)
        print_info(
            f'[INFO] Collected evidence for {NAME_RLS} for "{project_name}"', project_id=project_id)
        list_payload = []
        list_payload.append({
            'project_id': project_id,
            'evidence_what_for': evidence_what_for,
            'evidence_image_name': evidence_image_name,
            'evidence_image_size': evidence_image_size,
            'evidence_image_blob': evidence_image_blob,
            'evidence_image_last_updated_on_caa': int(time.time())
        })
        list_json_payload = json.dumps(list_payload)
        request_post_api(list_json_payload=list_json_payload,
                         db_table_name='evidence_images',
                         route_url='api/v1/evidence-images')

        anchors = page.locator('a').all()
        for anchor in anchors:
            try:
                href_table = anchor.get_attribute('href')
            except:
                continue

            if href_table and re.match(r"/dashboard/project/[^/]+/editor/[^/]+$", href_table):
                anchor.first.highlight()
                page.wait_for_timeout(HIGHLIGHT_DURATION)

                table_name = anchor.text_content()
                rls_status_button_outer_element = anchor.locator(
                    '..').locator('..')
                table_is_rls_enabled = True if 'Disable RLS' in rls_status_button_outer_element.inner_text() else False
                rls_status_button_outer_element.highlight()
                page.wait_for_timeout(HIGHLIGHT_DURATION)

                if not table_is_rls_enabled and not NAME_RLS in list_findings_discovered:
                    list_findings_discovered.append(NAME_RLS)
                    print_finding(
                        f'[FINDING] {NAME_RLS} for "{table_name}" ({project_name}) is disabled.',
                        project_id=project_id,
                        table_project_id=project_id,
                        table_name=table_name)

                list_table_project_id_fk.append(project_id)
                list_table_name.append(table_name)
                list_table_is_rls_enabled.append(table_is_rls_enabled)

    print_debug(
        '[DEBUG] list_table_name, list_table_project_id_fk, list_table_is_rls_enabled')
    print_debug(list_table_name, list_table_project_id_fk,
                list_table_is_rls_enabled)
    list_json_payload = []
    for i in range(len(list_table_project_id_fk)):
        table_is_rls_enabled = 1 if list_table_is_rls_enabled[i] else 0
        payload = {'project_id_fk': list_table_project_id_fk[i],
                   'table_name': list_table_name[i],
                   'table_is_rls_enabled': table_is_rls_enabled,
                   'table_last_updated_on_caa': int(time.time())}
        list_json_payload.append(payload)

    list_json_payload = json.dumps(list_json_payload)
    request_post_api(list_json_payload=list_json_payload,
                     db_table_name='tables',
                     route_url='api/v1/tables')

    list_findings_remediated = []
    list_findings_not_remediated = []
    # ----------------------------------------------------------------------- #
    # Remediation Action Flows
    # ----------------------------------------------------------------------- #
    if len(list_findings_discovered) == 0:
        print_info(f'[INFO] Closing resources...')
        context.close()
        browser.close()
        playwright.stop()
        return

    page.goto(f'{APP_URL_BASE}/dashboard/projects')
    page.get_by_text('New project').first.wait_for(state='visible')
    wait_for_all_loading(page, HIGHLIGHT_DURATION)

    print_info(
        '[INFO] Requesting for remediations action flow prompt...')
    str_findings_discovered = get_findings_summary_string(
        list_findings_discovered)
    is_yes = messagebox.askyesno(
        title='caa', message=f'Findings:{str_findings_discovered}\n\nWould you like to perform the remediation action flows? To start, please click Yes.')

    print_info(
        f'[INFO] Your dashboard is now updated at {VELDE_URL_BASE + "/dashboard"}')
    if not is_yes:
        messagebox.showinfo(
            title='caa', message=f'Your dashboard is now updated at {VELDE_URL_BASE + "/dashboard"}')
        exit_program()

    # ----------------------------------------------------------------------- #
    # Remediate MFA (Multi Factor Authentication)
    # ----------------------------------------------------------------------- #
    if NAME_MFA in list_findings_discovered:
        list_user_email_mfa_disabled = []
        for i in range(len(list_user_email)):
            user_email = list_user_email[i]
            if not list_user_is_mfa_enabled[i] and not user_email in list_user_email_mfa_disabled:
                list_user_email_mfa_disabled.append(user_email)

        for i in range(len(list_org_id)):
            org_id = list_org_id[i]
            org_name = list_org_name[i]
            org_url = list_org_url[i]

            team_url = f'{APP_URL_BASE}/{org_url}'.replace('general', 'team')
            page.goto(team_url)
            page.wait_for_load_state('domcontentloaded')
            page.get_by_role('row').first.wait_for(state='visible')

            page.wait_for_timeout(HIGHLIGHT_DURATION * 2)
            rows = page.get_by_role('row').all()
            for i in range(len(rows) - 2):
                row = rows[i + 1]
                cells = row.get_by_role('cell').all()
                user_email_candidate = cells[0].get_by_role(
                    'paragraph').first.text_content()

                user_is_mfa_enabled = False if user_email_candidate in list_user_email_mfa_disabled else True
                if not user_is_mfa_enabled:
                    cells[2].first.highlight()
                    page.wait_for_timeout(HIGHLIGHT_DURATION)
                    cells[0].first.highlight()
                    page.wait_for_timeout(HIGHLIGHT_DURATION * 2)

            messagebox.showinfo(
                title='caa', message=f"Every highlighted user should enable {NAME_MFA} at https://supabase.com/dashboard/account/security")

        list_findings_remediated.append(NAME_MFA)
        print_info(
            f'[INFO] Every highlighted user should enable {NAME_MFA} at https://supabase.com/dashboard/account/security')

    # ----------------------------------------------------------------------- #
    # Remediate PITR (Point-In-Time Recovery)
    # ----------------------------------------------------------------------- #
    if NAME_PITR in list_findings_discovered:
        list_projects_id_pitr_disabled = []
        list_projects_name_pitr_disabled = []
        for i in range(len(list_project_id)):
            project_id = list_project_id[i]
            project_name = list_project_name[i]
            if not list_project_is_pitr_enabled[i] and not project_id in list_projects_id_pitr_disabled:
                list_projects_id_pitr_disabled.append(project_id)
                list_projects_name_pitr_disabled.append(project_name)

        for i in range(len(list_projects_id_pitr_disabled)):
            project_id = list_projects_id_pitr_disabled[i]
            project_name = list_projects_name_pitr_disabled[i]
            url_pitr = f'{APP_URL_BASE}/dashboard/project/{project_id}/database/backups/pitr'
            page.goto(url_pitr)
            wait_for_all_loading(page, HIGHLIGHT_DURATION)

            page.get_by_text('Point in time').first.wait_for(state='visible')
            page.get_by_text('Point in time').first.highlight()
            page.wait_for_timeout(HIGHLIGHT_DURATION * 2)

            messagebox.showinfo(
                title='caa', message=f"{NAME_PITR} must be enabled for the project '{project_name}' at {url_pitr}")
            print_info(
                f'[INFO] {NAME_PITR} must be enabled for the project "{project_name}" at {url_pitr}', project_id=project_id)

        list_findings_remediated.append(NAME_PITR)

    # ----------------------------------------------------------------------- #
    # Remediate RLS (Row Level Security)
    # ----------------------------------------------------------------------- #
    if NAME_RLS in list_findings_discovered:
        list_table_project_id_fk_rls_disabled = []
        list_table_name_rls_disabled = []
        list_table_composite_key_rls_disabled = []
        list_table_rls_disabled_is_remediated = []
        for i in range(len(list_table_project_id_fk)):
            table_project_id_fk = list_table_project_id_fk[i]
            table_name = list_table_name[i]
            table_composite_key = f'{table_project_id_fk}_{table_name}'
            if not list_table_is_rls_enabled[i] and not table_composite_key in list_table_composite_key_rls_disabled:
                list_table_project_id_fk_rls_disabled.append(
                    table_project_id_fk)
                list_table_name_rls_disabled.append(table_name)
                list_table_composite_key_rls_disabled.append(
                    table_composite_key)
                list_table_rls_disabled_is_remediated.append(False)

        # Any records that change their value here will be sent as an HTTP
        # POST request later to reflect the changes in the database.
        list_updated_table_project_id_fk = []
        list_updated_table_name = []
        list_updated_table_is_rls_enabled = []
        is_all_rls_remediated = True
        for project_id_fk in list_table_project_id_fk_rls_disabled:
            for i in range(len(list_table_project_id_fk_rls_disabled)):
                table_project_id_fk = list_table_project_id_fk_rls_disabled[i]
                table_name = list_table_name_rls_disabled[i]
                table_composite_key = list_table_composite_key_rls_disabled[i]
                table_is_remediated = list_table_rls_disabled_is_remediated[i]

                if project_id_fk != table_project_id_fk or table_is_remediated:
                    continue

                try:
                    url = f'{APP_URL_BASE}/dashboard/project/{project_id_fk}/auth/policies'
                    page.goto(url)
                    wait_for_all_loading(page, HIGHLIGHT_DURATION)
                    anchors = page.locator('a').all()

                    rls_status_button_outer_element = ''
                    for anchor in anchors:
                        try:
                            href = anchor.get_attribute('href')
                        except:
                            pass

                        if href and re.match(r"/dashboard/project/[^/]+/editor/[^/]+$", href):
                            if anchor.text_content() == table_name:
                                rls_status_button_outer_element = anchor.locator(
                                    '..').locator('..')
                                break

                    rls_button = rls_status_button_outer_element.get_by_text(
                        'Enable RLS').first
                    anchor.first.highlight()
                    page.wait_for_timeout(HIGHLIGHT_DURATION * 2)
                    rls_button.highlight()
                    page.wait_for_timeout(HIGHLIGHT_DURATION * 2)
                    rls_button.click()
                    wait_for_all_loading(page, HIGHLIGHT_DURATION)

                    page.get_by_role(
                        'button', name='Confirm').first.highlight()
                    page.wait_for_timeout(HIGHLIGHT_DURATION * 2)
                    page.get_by_role(
                        'button', name='Confirm').first.click()
                    wait_for_all_loading(page, HIGHLIGHT_DURATION)

                    rls_button = rls_status_button_outer_element.get_by_text(
                        'Disable RLS').first
                    print_info(f'[INFO] Successful {NAME_RLS} remediation for the table "{table_name}".',
                               project_id=table_project_id_fk,
                               table_project_id=table_project_id_fk,
                               table_name=table_name)
                    list_table_rls_disabled_is_remediated[i] = True
                    list_updated_table_project_id_fk.append(
                        table_project_id_fk)
                    list_updated_table_name.append(table_name)
                    list_updated_table_is_rls_enabled.append(True)

                except:
                    print_error(f"[ERROR] {NAME_RLS} couldn't be enabled for the table {table_name}. Please check the logs and contact us <{VELDE_EMAIL}>.",
                                project_id=table_project_id_fk,
                                table_project_id=table_project_id_fk,
                                table_name=table_name)
                    is_all_rls_remediated = False

        if is_all_rls_remediated:
            message = f'Successful {NAME_RLS} remediation for all tables.'
            print_info(f'[INFO] {message}')
            list_findings_remediated.append(NAME_RLS)
        else:
            message = f"{NAME_RLS} remediation process has failed. Please check the logs and contact us <{VELDE_EMAIL}>."
            print_error(f"[ERROR] {message}")
            list_findings_not_remediated.append(NAME_RLS)
            messagebox.showinfo(
                title='caa', message=message)

        list_json_payload = []
        for i in range(len(list_updated_table_project_id_fk)):
            table_is_rls_enabled = 1 if list_updated_table_is_rls_enabled[i] else 0
            payload = {'project_id_fk': list_updated_table_project_id_fk[i],
                       'table_name': list_updated_table_name[i],
                       'table_is_rls_enabled': table_is_rls_enabled,
                       'table_last_updated_on_caa': int(time.time())}
            list_json_payload.append(payload)

        list_json_payload = json.dumps(list_json_payload)
        request_post_api(list_json_payload=list_json_payload,
                         db_table_name='tables',
                         route_url='api/v1/tables')

    # ----------------------------------------------------------------------- #
    # Conclusion of Remediation Action Flows
    # ----------------------------------------------------------------------- #
    is_all_remediated = True if len(list_findings_remediated) == len(
        list_findings_discovered) else False
    is_none_remediated = True if len(list_findings_not_remediated) == len(
        list_findings_discovered) else False
    is_some_remediated = True if not is_all_remediated and not is_none_remediated else False

    if is_all_remediated:
        str_findings_remediated = get_findings_summary_string(
            list_findings_remediated)
        messagebox.showinfo(
            title='caa', message=f'Successful Remediations:{str_findings_remediated}\n\nYour dashboard is now updated at {VELDE_URL_BASE + '/dashboard'}')

    elif is_none_remediated:
        str_findings_not_remediated = get_findings_summary_string(
            list_findings_not_remediated)
        messagebox.showinfo(
            title='caa', message=f'Action Required:{str_findings_not_remediated}\n\nPlease check the logs and contact us <{VELDE_EMAIL}>.')

    elif is_some_remediated:
        str_findings_remediated = get_findings_summary_string(
            list_findings_remediated)
        str_findings_not_remediated = get_findings_summary_string(
            list_findings_not_remediated)
        messagebox.showinfo(
            title='caa', message=f'Remediations Successfully Completed:{str_findings_remediated}\n\nAction Required:{str_findings_not_remediated}\n\nPlease check the logs and contact us <{VELDE_EMAIL}>.')

    print_info(f'[INFO] Closing resources...')
    context.close()
    browser.close()
    playwright.stop()


def main():
    os.environ['PWDEBUG'] = '1' if is_inspector_on else '0'
    try:
        pytest.main(['-x', f'{__file__}', '-qq', '-s'])
    except Exception as e:
        if is_debug_on:
            print(e)


if __name__ == '__main__':
    main()
    exit_program()
