import { NextResponse } from "next/server";
import { auth } from "@/auth";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";
import { promises as fs } from "fs";

const API_KEY_IDENTIFICATION_PREFIX = process.env
  .NEXT_PUBLIC_API_KEY_IDENTIFICATION_PREFIX as string;
const URL = process.env.NEXT_PUBLIC_URL as string;
const CONTACT_EMAIL = process.env.NEXT_PUBLIC_CONTACT_EMAIL as string;

// Only POST. GET doesn't make sense here because we don't store the user's
// original API key -- it's impossible to regenerate it. It's therefore
// possible only to generate it once for a given API key. DELETE doesn't
// make sense for this route as well because the /api/v1/client-side-api-keys
// already provides the functionality.
export async function POST() {
  try {
    // Check authentication.
    const oAuthSession = await auth();
    if (!oAuthSession) {
      return NextResponse.json(
        {
          message: "Authentication failed.",
        },
        { status: 401, statusText: "Unauthorized" }
      );
    }

    // Proceed if authenticated.
    let userAuthenticatedID;
    let userAuthenticatedEmail;
    if (oAuthSession.user) {
      userAuthenticatedID = oAuthSession.user.id;
      userAuthenticatedEmail = oAuthSession.user.email;
    }

    const client_side_api_key_delete = prisma.client_side_api_keys.deleteMany({
      where: {
        caa_user_id: userAuthenticatedID as string,
      },
    });

    const client_side_api_key = crypto.randomUUID();
    const salt = await bcrypt.genSalt(10);
    const client_side_api_key_hashed =
      API_KEY_IDENTIFICATION_PREFIX +
      (await bcrypt.hash(client_side_api_key, salt));
    const client_side_api_key_create = prisma.client_side_api_keys.create({
      data: {
        caa_user_id: userAuthenticatedID as string,
        client_side_api_key_hashed_value: client_side_api_key_hashed,
        client_side_api_key_is_active: 1,
        client_side_api_key_time_generated: Math.floor(
          new Date().getTime() / 1000
        ),
      },
    });

    await prisma.$transaction([
      client_side_api_key_delete,
      client_side_api_key_create,
    ]);

    const file = await fs.readFile(
      process.cwd() + "/src/python/caa_supabase.py",
      "utf8"
    );
    let fileGenerated = file.replaceAll(
      "# This section is auto generated by #REPLACE#",
      `# This section is auto generated by ${URL}`
    );
    fileGenerated = fileGenerated.replace(
      "# Designed for: #REPLACE#",
      `# Designed for: ${userAuthenticatedID}`
    );
    fileGenerated = fileGenerated.replace(
      "# Generated at: #REPLACE#",
      `# Generated at: ${new Date().toISOString()}`
    );
    fileGenerated = fileGenerated.replace(
      "VELDE_REST_API_USER = '#REPLACE#'",
      `VELDE_REST_API_USER = '${userAuthenticatedID}'`
    );
    fileGenerated = fileGenerated.replace(
      "VELDE_REST_API_KEY = '#REPLACE#'",
      `VELDE_REST_API_KEY = '${client_side_api_key}'`
    );
    fileGenerated = fileGenerated.replace(
      "VELDE_URL_BASE = '#REPLACE#'",
      `VELDE_URL_BASE = '${URL}'`
    );
    fileGenerated = fileGenerated.replace(
      "VELDE_EMAIL = '#REPLACE#'",
      `VELDE_EMAIL = '${CONTACT_EMAIL}'`
    );
    fileGenerated = fileGenerated.replace(
      "USER_EMAIL = '#REPLACE#'",
      `USER_EMAIL = '${userAuthenticatedEmail}'`
    );
    fileGenerated = fileGenerated.replace(
      "USER_UID = '#REPLACE#'",
      `USER_UID = '${userAuthenticatedID}'`
    );
    fileGenerated = fileGenerated.replace(
      "APP_URL_BASE = '#REPLACE#'",
      `APP_URL_BASE = 'https://supabase.com'`
    );
    fileGenerated = fileGenerated.replace(
      "APP_NAME = '#REPLACE#'",
      `APP_NAME = 'Supabase'`
    );

    return NextResponse.json(fileGenerated.toString(), {
      status: 201,
      statusText: "Created",
      headers: {
        "Content-Type": "text/x-python",
      },
    });
  } catch (err) {
    console.log(err);
    return NextResponse.json(
      {
        message: "Error occurred.",
      },
      {
        status: 400,
        statusText: "Bad Request",
      }
    );
  }
}
